<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>FGO 이벤트 주회 시뮬레이터 (Web · Pyodide)</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<link rel="preload" href="https://cdn.jsdelivr.net/pyodide/v0.26.2/full/pyodide.js" as="script">
<style>
  :root{color-scheme:dark light}
  body{font-family:ui-sans-serif,system-ui,Apple SD Gothic Neo,Segoe UI,Roboto,Helvetica,Arial,'Apple Color Emoji','Segoe UI Emoji';margin:0;background:#0b0d10;color:#e7eaf0}
  .wrap{max-width:1100px;margin:24px auto;padding:0 16px}
  h1{font-size:20px;margin:4px 0 12px 0}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .card{background:#12161c;border:1px solid #1e2530;border-radius:12px;padding:12px}
  .pill{display:inline-flex;align-items:center;background:#0f1320;border:1px solid #1b2334;border-radius:999px;padding:8px 10px;gap:8px}
  input[type="number"]{background:#0d1218;border:1px solid #1b2334;color:#e7eaf0;border-radius:10px;padding:8px 10px;width:110px}
  input.small{width:86px}
  input.qp{width:120px}
  button{background:#2b64ff;border:0;color:#fff;border-radius:12px;padding:10px 14px;font-weight:600;cursor:pointer}
  button:disabled{opacity:.65;cursor:not-allowed}
  .muted{opacity:.75}
  .tbl{width:100%;border-collapse:collapse;font-size:14px}
  .tbl th,.tbl td{border-bottom:1px solid #1e2530;padding:8px 10px;text-align:left}
  .tbl th{position:sticky;top:0;background:#0f141b;border-bottom:1px solid #263042}
  .note{font-size:12px;opacity:.8}
  .log{white-space:pre-wrap;background:#0a0d12;border:1px solid #1b2334;border-radius:12px;padding:12px;min-height:220px}
  .right{text-align:right}
  .sep{height:8px}
  .ok{color:#84f089}
  .warn{color:#ffd46a}
  .err{color:#ff7b7b}
  .kbd{font-family:ui-monospace,Menlo,Consolas,monospace;background:#0f1420;border:1px solid #1b2334;border-radius:6px;padding:1px 6px}
</style>
</head>
<body>
<div class="wrap">
  <h1>FGO 이벤트 주회 시뮬레이터 (Web)</h1>

  <div class="row">
    <div class="pill">
      <span class="muted">금사과</span><input id="apGold" type="number" min="0" step="1" value="0" class="small">
    </div>
    <div class="pill">
      <span class="muted">은사과</span><input id="apSilver" type="number" min="0" step="1" value="0" class="small">
    </div>
    <div class="pill">
      <span class="muted">청사과</span><input id="apBlue" type="number" min="0" step="1" value="0" class="small">
    </div>
    <div class="pill">
      <span class="muted">동사과</span><input id="apCopper" type="number" min="0" step="1" value="0" class="small">
    </div>
    <div class="pill muted">AP/판은 40 고정, 표는 text+ascii 고정</div>
  </div>

  <div class="sep"></div>

  <div class="card">
    <div class="row" style="justify-content:space-between;align-items:center">
      <div class="row" style="gap:14px">
        <div class="pill">
          <span class="muted">아이템 검색(이름 일부)</span>
          <input id="q" type="text" placeholder="예: 몬스터의 발톱">
        </div>
        <div class="note">표는 기본 <code>materials.json</code> 항목을 불러옵니다. (have/need만 수정)</div>
      </div>
      <div class="row" style="gap:8px">
        <button id="btnRun">시뮬레이션 실행</button>
      </div>
    </div>

    <div class="sep"></div>

    <div class="note">
      • <b>사과/묘목/프리즘/인연/종화</b>는 <span class="warn">재료 목록에서 제외</span>됩니다(사과는 상단 입력, 나머지는 계산 제외).<br>
      • <b>QP</b>는 <b>100만 단위(M)</b>로 표기/입력됩니다. 예) 1530만 QP → <span class="kbd">15.3</span>
    </div>

    <div class="sep"></div>

    <div style="max-height:380px;overflow:auto;border:1px solid #1e2530;border-radius:12px">
      <table class="tbl" id="matTable">
        <thead>
          <tr>
            <th style="width:28%">재료</th>
            <th style="width:12%">tier</th>
            <th style="width:12%">ap/개</th>
            <th style="width:12%">use</th>
            <th style="width:18%">have</th>
            <th style="width:18%">need</th>
          </tr>
        </thead>
        <tbody id="matBody"></tbody>
      </table>
    </div>
  </div>

  <div class="sep"></div>

  <div class="card">
    <div class="row" style="justify-content:space-between;align-items:center">
      <div><b>결과 로그</b> <span id="status" class="muted">— 준비됨</span></div>
      <div class="note">첫 로딩은 Pyodide 다운로드로 5–20초 걸릴 수 있어요. 이후엔 빠릅니다.</div>
    </div>
    <div class="sep"></div>
    <div id="log" class="log">여기에 실행 로그가 표시됩니다.</div>
  </div>

</div>

<!-- ────────────────────────────────────────────────────────────────────────
     1) 파이썬 시뮬레이터 원본 코드 (그대로 보관)
     ──────────────────────────────────────────────────────────────────────── -->
<script id="py-sim" type="text/plain">
# -*- coding: utf-8 -*-
"""
FGO 이벤트 주회 시뮬레이터 (Pro v2.5 — 전체 주석/정렬/정밀 출력/표 렌더 개선 + 아이템명 검증)
=============================================================================================

(원본 설명 생략) — 웹에서 실행을 위해 main()은 sys.argv로 인자 주입해 호출합니다.
"""

import json
import argparse
import unicodedata
import difflib
from typing import Dict, List, Tuple, Optional

APPLE_AP_BY_POOL = {"gold": 145.0, "silver": 73.0, "blue": 40.0, "copper": 10.0}
APPLE_NAME_TO_POOL = {"금사과": "gold", "은사과": "silver", "청사과": "blue", "동사과": "copper"}
APPLE_ITEM_NAMES = set(APPLE_NAME_TO_POOL.keys())
APPLE_COUNTS = {"gold": 0, "silver": 0, "blue": 0, "copper": 0}
NATURAL_AP = 0.0

RARITY_MAP: Optional[Dict[str, set]] = None

ITEM_SORT_INDEX: Dict[str, int] = {}
TIER_ORDER_INDEX: Dict[str, int] = {}
ITEM_TO_TIER: Dict[str, str] = {}

CE_BASE_BONUS = 7
CE_MAX_BONUS = 12
CE_COPIES_PER_PLUS = 4
CE_STATE: Dict[str, dict] = {}

SPECIAL_PER_RUN_YIELDS = {}

CURRENT_RUN_GAINS: Optional[Dict[str, float]] = None
_AGT_CALL_DEPTH = 0

TABLE_FORMAT = "text"
TABLE_STYLE  = "ascii"
AMBIGUOUS_WIDE = False
ARROW  = "->"
BULLET = "-"

BOX_CHARS   = {"top":("+","+","+"), "mid":("+","+","+"), "bot":("+","+","+"), "h":"-", "v":"|"}
ASCII_CHARS = BOX_CHARS

def r2(x: float) -> float:
    return round(float(x), 2)

def f2(x: float) -> str:
    return f"{float(x):,.2f}"

def f2s(x) -> str:
    try:
        if x == float("inf") or str(x).lower() == "inf":
            return "∞"
        return f2(float(x))
    except Exception:
        return str(x)

def f0(x) -> str:
    try:
        return f"{int(round(float(x))):,}"
    except Exception:
        return str(x)

def load_json(path: str) -> dict:
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

try:
    from wcwidth import wcswidth as _lib_wcswidth  # type: ignore
    def _display_width(s: str) -> int:
        return _lib_wcswidth(s)
except Exception:
    def _display_width(s: str) -> int:
        width = 0
        for ch in s:
            if unicodedata.combining(ch):
                continue
            ea = unicodedata.east_asian_width(ch)
            if ea in ("F", "W") or (ea == "A" and AMBIGUOUS_WIDE):
                width += 2
            else:
                width += 1
        return width

def to_material_index(materials_json: dict) -> Dict[str, dict]:
    index: Dict[str, dict] = {}
    for m in materials_json.get("materials", []):
        name = str(m.get("item") or "").strip()
        if not name:
            continue
        ap_raw = m.get("ap_per_item")
        lack_raw = m.get("lack")
        index[name] = {
            "ap": float(ap_raw) if ap_raw is not None else 0.0,
            "lack": float(lack_raw) if lack_raw is not None else 0.0,
            "use": str(m.get("use") or "Y").upper() == "Y",
        }
    return index

def init_rarity_map_from_materials(materials_json: dict) -> None:
    global RARITY_MAP
    rm = materials_json.get("rarity_map")
    if isinstance(rm, dict):
        RARITY_MAP = {
            "gold":   set(str(x) for x in rm.get("gold", [])   if x),
            "silver": set(str(x) for x in rm.get("silver", []) if x),
            "bronze": set(str(x) for x in rm.get("bronze", []) if x),
        }
    else:
        RARITY_MAP = {"gold": set(), "silver": set(), "bronze": set()}

def init_sort_index_from_materials(materials_json: dict) -> None:
    global ITEM_SORT_INDEX, TIER_ORDER_INDEX, ITEM_TO_TIER
    ITEM_SORT_INDEX = {}
    TIER_ORDER_INDEX = {}
    ITEM_TO_TIER = {}
    for i, m in enumerate(materials_json.get("materials", [])):
        name = str(m.get("item") or "").strip()
        tier = str(m.get("tier") or "").strip()
        if not name:
            continue
        if name not in ITEM_SORT_INDEX:
            ITEM_SORT_INDEX[name] = i
        ITEM_TO_TIER[name] = tier
        if tier and tier not in TIER_ORDER_INDEX:
            TIER_ORDER_INDEX[tier] = len(TIER_ORDER_INDEX)

def default_rarity_map() -> Dict[str, set]:
    return RARITY_MAP if RARITY_MAP is not None else {"gold": set(), "silver": set(), "bronze": set()}

def classify_rarity(item: str, rarity_map: Dict[str, set]) -> Optional[str]:
    for rarity in ("gold", "silver", "bronze"):
        if item in rarity_map[rarity]:
            return rarity
    return None

def _material_sort_key(name: str):
    idx = ITEM_SORT_INDEX.get(name, 10**9)
    tier = ITEM_TO_TIER.get(name, "")
    to = TIER_ORDER_INDEX.get(tier, 10**9)
    return (idx, to, name)

def mat_rec(item: str, materials_index: Dict[str, dict]) -> Optional[dict]:
    return materials_index.get(item)

def mat_ap(item: str, materials_index: Dict[str, dict], respect_use_flag: bool=True) -> float:
    rec = mat_rec(item, materials_index)
    if not rec:
        return 0.0
    if respect_use_flag and not rec.get("use", True):
        return 0.0
    if float(rec.get("lack") or 0.0) <= 0.0:
        return 0.0
    return float(rec.get("ap") or 0.0)

def mat_lack(item: str, materials_index: Dict[str, dict]) -> float:
    rec = mat_rec(item, materials_index)
    return float(rec["lack"]) if rec else 0.0

def mat_usable(item: str, materials_index: Dict[str, dict]) -> bool:
    rec = mat_rec(item, materials_index)
    return (rec["use"] if rec is not None else True)

def snapshot_lack(materials_index: Dict[str, dict], respect_use_flag: bool=True) -> Dict[str, float]:
    return {
        name: float(rec.get("lack") or 0.0)
        for name, rec in materials_index.items()
        if not (respect_use_flag and not rec.get("use", True))
    }

def _iter_item_blocks(items_def: dict) -> List[dict]:
    if isinstance(items_def.get("event_items"), list):
        return items_def["event_items"]
    if isinstance(items_def.get("event_quests"), list):
        return items_def["event_quests"]
    return []

def _collect_from_box_contents(container: dict, where: str, report):
    if not isinstance(container, dict):
        return
    for rar in ("gold", "silver", "bronze"):
        for ent in (container.get(rar) or []):
            item = str((ent or {}).get("item") or "").strip()
            if item:
                report(item, f"{where}/box:{rar}")

def validate_item_names(materials_index: Dict[str, dict], quests_def: dict, items_def: dict) -> Dict[str, List[str]]:
    known = set(materials_index.keys()) | APPLE_ITEM_NAMES | {"교환티켓"}
    unknown: Dict[str, List[str]] = {}
    def report(name: str, where: str):
        if not name: return
        n = name.strip()
        if n in known: return
        lst = unknown.setdefault(n, [])
        if len(lst) < 5 and where not in lst: lst.append(where)

    rmap = default_rarity_map()
    for rar in ("gold", "silver", "bronze"):
        for nm in rmap.get(rar, []):
            if nm not in known:
                report(nm, f"materials.rarity_map.{rar}")

    for e in quests_def.get("event_quests", []):
        ev = str(e.get("event") or "").strip()
        cs = str(e.get("case") or "").lower()
        for st in e.get("stages", []):
            stg = str(st.get("stage") or "").strip()
            dff = str(st.get("diff") or "").strip()
            for d in st.get("drops", []):
                item = str(d.get("item") or "").strip()
                if item: report(item, f"event_quests/{ev}/{cs}/{stg}[{dff}]/drops")
            box = st.get("box") or {}
            for key in ("items", "contents"):
                if key in box and isinstance(box[key], dict):
                    _collect_from_box_contents(box[key], f"event_quests/{ev}/{cs}/{stg}[{dff}]", report)
        if isinstance(e.get("box_contents"), dict):
            _collect_from_box_contents(e["box_contents"], f"event_quests/{ev}/{cs}", report)

    if isinstance(quests_def.get("box_contents"), dict):
        _collect_from_box_contents(quests_def["box_contents"], "event_quests/top", report)

    for blk in _iter_item_blocks(items_def):
        ev = str(blk.get("event") or "").strip()
        cs = str(blk.get("case") or "").lower()
        for d in blk.get("drops", []):
            item = str(d.get("item") or "").strip()
            if item: report(item, f"event_items/{ev}/{cs}/drops")
        for ex in blk.get("exchanges", []) or []:
            for opt in (ex.get("options") or []):
                item = str(opt or "").strip()
                if item: report(item, f"event_items/{ev}/{cs}/exchanges")
        if cs == "box":
            for d in blk.get("drops", []):
                item = str(d.get("item") or "").strip()
                if item: report(item, f"event_items/{ev}/{cs}/box_drops")

    return unknown

def _draw_line(widths, left="+", mid="+", right="+", fill="-"):
    parts = [left]
    for i, w in enumerate(widths):
        parts.append(fill * (w + 2))
        parts.append(mid if i < len(widths) - 1 else right)
    return "".join(parts)

def _pad_cell(text: str, width: int, align: str) -> str:
    t = str(text)
    display = _display_width(t)
    pad = max(0, width - display)
    if align == "right":
        return " " + (" " * pad + t) + " "
    if align == "center":
        left = pad // 2; right = pad - left
        return " " + (" " * left + t + " " * right) + " "
    return " " + (t + " " * pad) + " "

def _print_table_text(write_line, headers, rows, aligns=None):
    if aligns is None:
        aligns = ["left"] * len(headers)
    chars = ASCII_CHARS
    v = chars["v"]
    widths = []
    for col in range(len(headers)):
        maxw = _display_width(str(headers[col]))
        for r in rows: maxw = max(maxw, _display_width(str(r[col])))
        widths.append(maxw)
    write_line(_draw_line(widths, *chars["top"], fill=chars["h"]))
    write_line(v + v.join(_pad_cell(str(h), widths[i], "center") for i, h in enumerate(headers)) + v)
    write_line(_draw_line(widths, *chars["mid"], fill=chars["h"]))
    for r in rows:
        write_line(v + v.join(_pad_cell(str(r[i]), widths[i], aligns[i]) for i in range(len(headers))) + v)
    write_line(_draw_line(widths, *chars["bot"], fill=chars["h"]))

def _print_table_md(write_line, headers, rows, aligns=None):
    if aligns is None: aligns = ["left"] * len(headers)
    write_line("| " + " | ".join(str(h) for h in headers) + " |")
    align_map = {"left": ":---", "right": "---:", "center": ":---:"}
    write_line("| " + " | ".join(align_map.get(a, ":---") for a in aligns) + " |")
    for r in rows: write_line("| " + " | ".join(str(c) for c in r) + " |")

def _csv_escape(s: str) -> str:
    s = str(s)
    if any(ch in s for ch in [",", "\"", "\n", "\r"]):
        return "\"" + s.replace("\"", "\"\"") + "\""
    return s

def _print_table_csv(write_line, headers, rows, aligns=None):
    write_line(",".join(_csv_escape(h) for h in headers))
    for r in rows: write_line(",".join(_csv_escape(c) for c in r))

def _print_table(write_line, headers, rows, aligns=None):
    if TABLE_FORMAT == "md": _print_table_md(write_line, headers, rows, aligns)
    elif TABLE_FORMAT == "csv": _print_table_csv(write_line, headers, rows, aligns)
    else: _print_table_text(write_line, headers, rows, aligns)

def _print_gain_table(write_line, current_gains: Dict[str, float], lack_before: Dict[str, float], lack_after: Dict[str, float], cum_gained: Dict[str, float]):
    if not current_gains: write_line("  (변동 없음)"); return
    headers = ["항목", "+획득", "누적", "부족(전->후)"]
    names_sorted = sorted(current_gains.keys(), key=_material_sort_key)
    rows = []
    for name in names_sorted:
        gained = current_gains.get(name, 0.0)
        b = lack_before.get(name, 0.0)
        a = lack_after.get(name, 0.0)
        total = cum_gained.get(name, 0.0)
        rows.append([name, f2(gained), f2(total), f"{f2(b)} {ARROW} {f2(a)}"])
    _print_table(write_line, headers, rows, aligns=["left", "right", "right", "right"])

def _print_eff_table(write_line, best_list: List[dict], ap_cost_per_run: float):
    headers = ["이벤트", "스테이지[난이도]", "total/AP"]
    rows = []
    for b in best_list:
        ev = b.get("event")
        st = b.get("stage")
        df = b.get("diff")
        total_eff = b.get("total_eff", 0.0)
        rows.append([ev, f"{st} [{df}]", f2s(total_eff)])
    _print_table(write_line, headers, rows, aligns=["left", "left", "right"])

class Logger:
    def __init__(self, filepath: str, tee: bool=False):
        self.filepath = filepath
        self.tee = tee
        self.f = open(filepath, "w", encoding="utf-8")
    def write(self, line: str=""):
        self.f.write(line + "\n")
        if self.tee: print(line)
    def close(self):
        try: self.f.flush(); self.f.close()
        except Exception: pass

def apply_gain_and_track(item: str, qty: float, materials_index: Dict[str, dict], cum_gained: Dict[str, float], respect_use_flag: bool=True) -> None:
    global CURRENT_RUN_GAINS, _AGT_CALL_DEPTH
    _AGT_CALL_DEPTH += 1
    try:
        if _AGT_CALL_DEPTH > 1: return
        if qty > 0:
            cum_gained[item] = cum_gained.get(item, 0.0) + float(qty)
            if CURRENT_RUN_GAINS is not None:
                CURRENT_RUN_GAINS[item] = CURRENT_RUN_GAINS.get(item, 0.0) + float(qty)
        rec = mat_rec(item, materials_index)
        if rec is None or (respect_use_flag and not rec.get("use", True)): return
        before = float(rec.get("lack") or 0.0)
        after = before - float(qty)
        rec["lack"] = after if after > 0 else 0.0
    finally:
        _AGT_CALL_DEPTH -= 1

def _apply_special_per_run_yields(event_name: str, materials_index: Dict[str, dict], cum_gained: Dict[str, float], respect_use_flag: bool=True) -> None:
    for key, yields_ in SPECIAL_PER_RUN_YIELDS.items():
        if key in str(event_name):
            for row in yields_:
                apply_gain_and_track(str(row["item"]), float(row["qty"]), materials_index, cum_gained, respect_use_flag)

def allocate_exchange_tokens_ap_first(token_qty: float, per_token: float, options: List[str], materials_index: Dict[str, dict], respect_use_flag: bool=True) -> List[Tuple[str, float]]:
    candidates = []
    for it in options:
        if not mat_usable(it, materials_index): continue
        if mat_lack(it, materials_index) <= 0: continue
        apv = mat_ap(it, materials_index, respect_use_flag)
        candidates.append((it, apv, mat_lack(it, materials_index)))
    candidates.sort(key=lambda x: x[1], reverse=True)
    remain = token_qty * per_token
    allocation = []
    for it, _, lack in candidates:
        if remain <= 0: break
        room = max(lack, 0.0)
        if room <= 0: continue
        take = min(remain, room)
        if take > 0:
            allocation.append((it, take))
            remain -= take
    return allocation

def get_items_block(event_name: str, items_def: dict, case: str) -> Optional[dict]:
    target = str(event_name).strip()
    for b in _iter_item_blocks(items_def):
        if str(b.get("event") or "").strip() == target and str(b.get("case") or "").lower() == case:
            return b
    return None

def extract_need_tickets_from_items(event_name: str, items_def: dict, default: float=600.0) -> float:
    blk = get_items_block(event_name, items_def, case="roulette")
    if not blk: return default
    try: return float(blk.get("need_tickets") or default)
    except Exception: return default

def compute_per_box_value_and_refund(event_name: str, items_def: dict, materials_index: Dict[str, dict], respect_use_flag: bool=True, apple_ap_map: Dict[str, float]=None) -> Tuple[float, float, List[dict]]:
    if apple_ap_map is None:
        apple_ap_map = {k: APPLE_AP_BY_POOL[v] for k, v in APPLE_NAME_TO_POOL.items()}
    blk = get_items_block(event_name, items_def, case="roulette")
    per_box = 0.0
    refund = 0.0
    details = []
    if not blk: return 0.0, 0.0, details
    token_name = None
    token_rate = 0.0
    for d in blk.get("drops", []):
        item = str(d.get("item") or "")
        rate = float(d.get("rate") or 0.0)
        if not item: continue
        if item in apple_ap_map:
            refund += rate * apple_ap_map[item]; continue
        if item == "교환티켓":
            token_name = item; token_rate = rate; continue
        apv = mat_ap(item, materials_index, respect_use_flag)
        val = apv * rate
        per_box += val
        details.append({"kind": "drop", "item": item, "qty_per_box": rate, "ap_per_item": apv, "ap_value": r2(val)})
    if token_name and token_rate > 0:
        for ex in blk.get("exchanges", []):
            if str(ex.get("token")) != token_name: continue
            per_token = float(ex.get("per_token") or 1.0)
            options = [str(x) for x in ex.get("options", []) if x]
            alloc = allocate_exchange_tokens_ap_first(token_rate, per_token, options, materials_index, respect_use_flag)
            for it, qty in alloc:
                apv = mat_ap(it, materials_index, respect_use_flag)
                val = apv * qty
                per_box += val
                details.append({"kind": "exchange", "item": it, "qty": r2(qty), "ap_per_item": apv, "ap_value": r2(val)})
    return r2(per_box), r2(refund), details

def tickets_per_run(stage_def: dict, ce_count: int) -> float:
    t = stage_def.get("tickets") or {}
    return float(t.get("base") or 0.0) + float(t.get("per_ce") or 0.0) * ce_count

def stage_value_per_run(stage_drops: List[dict], materials_index: Dict[str, dict], respect_use_flag: bool=True) -> float:
    val = 0.0
    for d in stage_drops:
        item = str(d.get("item") or ""); rate = float(d.get("rate") or 0.0)
        if not item: continue
        val += mat_ap(item, materials_index, respect_use_flag) * rate
    return val

def default_rarity_sum(event_name: str, items_def: dict, materials_index: Dict[str, dict], respect_use_flag: bool=True) -> Tuple[float, float, float, str, List[dict]]:
    blk = get_items_block(event_name, items_def, case="box")
    if not blk: return 0.0, 0.0, 0.0, "none", []
    rarity_map = default_rarity_map()
    sum_gold = sum_silver = sum_bronze = 0.0
    dbg = []
    for d in blk.get("drops", []):
        item = str(d.get("item") or ""); rate = float(d.get("rate") or 0.0)
        if not item: continue
        apv = mat_ap(item, materials_index, respect_use_flag)
        rar = classify_rarity(item, rarity_map)
        val = apv * rate
        if rar == "gold":   sum_gold += val
        elif rar == "silver": sum_silver += val
        elif rar == "bronze": sum_bronze += val
        dbg.append({"item": item, "rarity": rar or "?", "rate": rate, "ap_per_item": apv, "ap_value": r2(val)})
    return r2(sum_gold), r2(sum_silver), r2(sum_bronze), "event_items", dbg

def _fetch_box_contents(stage_def: dict, event_block: dict, quests_def: dict) -> Dict[str, List[dict]]:
    box = stage_def.get("box") or {}
    if isinstance(box.get("items"), dict): return box["items"]
    if isinstance(box.get("contents"), dict): return box["contents"]
    if isinstance(event_block.get("box_contents"), dict): return event_block["box_contents"]
    if isinstance(quests_def.get("box_contents"), dict): return quests_def["box_contents"]
    return {}

def _rarity_sum_ap(lst: List[dict], materials_index: Dict[str, dict], respect_use_flag: bool=True) -> float:
    if not lst: return 0.0
    total = 0.0
    has_qty = any('qty_per_box' in (x or {}) for x in lst)
    has_rate = any('rate' in (x or {}) for x in lst)
    n = len(lst)
    for x in lst or []:
        item = str((x or {}).get("item") or "")
        if not item: continue
        if has_qty: qty = float((x or {}).get("qty_per_box") or 0.0)
        elif has_rate: qty = float((x or {}).get("rate") or 0.0)
        else: qty = 1.0 / n if n > 0 else 0.0
        total += mat_ap(item, materials_index, respect_use_flag) * qty
    return total

def _build_box_contents_from_items_json(event_name: str, items_def: dict) -> Dict[str, List[dict]]:
    blk = get_items_block(event_name, items_def, case="box")
    if not blk: return {}
    rarity_map = default_rarity_map()
    groups = {"gold": [], "silver": [], "bronze": []}
    for d in blk.get("drops", []):
        item = str(d.get("item") or "").strip()
        if not item: continue
        rar = classify_rarity(item, rarity_map)
        if rar not in ("gold", "silver", "bronze"): continue
        entry = {"item": item}
        if "qty_per_box" in d:
            try: entry["qty_per_box"] = float(d.get("qty_per_box") or 0.0)
            except Exception: entry["qty_per_box"] = 0.0
        elif "rate" in d:
            try: entry["rate"] = float(d.get("rate") or 0.0)
            except Exception: entry["rate"] = 0.0
        groups[rar].append(entry)
    for rar in ("gold", "silver", "bronze"):
        lst = groups[rar]
        if not lst: continue
        has_qty = any("qty_per_box" in x for x in lst)
        has_rate = any("rate" in x for x in lst)
        if not has_qty and not has_rate:
            n = len(lst)
            for x in lst: x["rate"] = 1.0 / n if n > 0 else 0.0
    return groups

def compute_box_event_best_stage(event_name: str, quests_def: dict, items_def: dict, materials_index: Dict[str, dict], ap_cost_per_run: float, prefer_diff: Optional[str], respect_use_flag: bool=True) -> Optional[dict]:
    events = quests_def.get("event_quests", [])
    candidates = []
    for e in events:
        if str(e.get("event") or "") != event_name or str(e.get("case") or "").lower() != "box":
            continue
        for st in e.get("stages", []):
            stage_val = stage_value_per_run(st.get("drops", []), materials_index, respect_use_flag)
            box = st.get("box") or {}
            base_gold = float((box.get("gold") or {}).get("base", 0.0))
            base_silver = float((box.get("silver") or {}).get("base", 0.0))
            base_bronze = float((box.get("bronze") or {}).get("base", 0.0))
            contents = _fetch_box_contents(st, e, quests_def)
            dbg_rows = []; source = ""
            if contents:
                sum_gold = _rarity_sum_ap(contents.get("gold", []), materials_index, respect_use_flag)
                sum_silver = _rarity_sum_ap(contents.get("silver", []), materials_index, respect_use_flag)
                sum_bronze = _rarity_sum_ap(contents.get("bronze", []), materials_index, respect_use_flag)
                source = "stage.contents"
            else:
                sg, ss, sb, src, dbg = default_rarity_sum(event_name, items_def, materials_index, respect_use_flag)
                sum_gold, sum_silver, sum_bronze = sg, ss, sb
                source = src
                dbg_rows = dbg
            box_val = sum_gold * base_gold + sum_silver * base_silver + sum_bronze * base_bronze
            total_eff = (stage_val + box_val) / ap_cost_per_run if ap_cost_per_run > 0 else 0.0
            candidates.append({
                "stage": st.get("stage"), "diff": st.get("diff"),
                "stage_val_per_run": r2(stage_val), "box_val_per_run": r2(box_val),
                "total_eff": r2(total_eff),
                "details": {"base": {"gold": base_gold, "silver": base_silver, "bronze": base_bronze},
                            "sum_ap": {"gold": r2(sum_gold), "silver": r2(sum_silver), "bronze": r2(sum_bronze)},
                            "source": source, "drops": st.get("drops", []),
                            "event_items_dbg": dbg_rows}
            })
        break
    if not candidates: return None
    if prefer_diff:
        pref = [c for c in candidates if str(c.get("diff") or "") == str(prefer_diff)]
        if pref: return max(pref, key=lambda x: float(x["total_eff"]))
    return max(candidates, key=lambda x: float(x["total_eff"]))

def _get_event_block(quests_def: dict, event_name: str, case: str) -> Optional[dict]:
    for e in quests_def.get("event_quests", []):
        if str(e.get("event") or "") == event_name and str(e.get("case") or "").lower() == case:
            return e
    return None

def choose_best_stage_by_total_eff_roulette(event_name: str, quests_def: dict, items_def: dict, ce_count: int, need_tickets_default: float, ap_cost_per_run: float, materials_index: Dict[str, dict], respect_use_flag: bool=True) -> Optional[dict]:
    need_tk = extract_need_tickets_from_items(event_name, items_def, default=need_tickets_default)
    per_box_value, apple_refund_ap, box_details = compute_per_box_value_and_refund(event_name, items_def, materials_index, respect_use_flag)
    events = quests_def.get("event_quests", []); candidates = []
    for e in events:
        if str(e.get("event") or "") != event_name or str(e.get("case") or "").lower() != "roulette":
            continue
        for st in e.get("stages", []):
            tpr = tickets_per_run(st, ce_count)
            stage_run_val = stage_value_per_run(st.get("drops", []), materials_index, respect_use_flag)
            stage_eff_per_ap = (stage_run_val / ap_cost_per_run) if ap_cost_per_run > 0 else 0.0
            if need_tk > 0 and tpr > 0:
                runs_per_box = need_tk / tpr
                gross_ap_per_box = runs_per_box * ap_cost_per_run
                net_ap_per_box = gross_ap_per_box - apple_refund_ap
            else:
                net_ap_per_box = 0.0
            if net_ap_per_box <= 0:
                roulette_eff = total_eff = float("inf")
            else:
                roulette_eff = per_box_value / net_ap_per_box
                total_eff = stage_eff_per_ap + roulette_eff
            candidates.append({
                "stage": st.get("stage"), "diff": st.get("diff"),
                "tickets_per_run": r2(tpr), "stage_val_per_run": r2(stage_run_val),
                "stage_eff_per_ap": r2(stage_eff_per_ap),
                "roulette_eff": (roulette_eff if roulette_eff == float("inf") else r2(roulette_eff)),
                "total_eff": (total_eff if total_eff == float("inf") else r2(total_eff)),
                "need_tickets": need_tk, "per_box_value": r2(per_box_value),
                "apple_refund_ap": r2(apple_refund_ap), "stage_drops": st.get("drops", []),
                "box_details": box_details
            })
        break
    if not candidates: return None
    def key_fn(x): return float("inf") if x["total_eff"] == float("inf") else float(x["total_eff"])
    return max(candidates, key=key_fn)

def compute_raid_best_stage(event_name: str, quests_def: dict, materials_index: Dict[str, dict], ap_cost_per_run: float, respect_use_flag: bool=True, prefer_diff: Optional[str]=None) -> Optional[dict]:
    events = quests_def.get("event_quests", []); candidates = []
    for e in events:
        if str(e.get("event") or "") != event_name or str(e.get("case") or "").lower() != "raid":
            continue
        for st in e.get("stages", []):
            stage_val = stage_value_per_run(st.get("drops", []), materials_index, respect_use_flag)
            stage_eff = (stage_val / ap_cost_per_run) if ap_cost_per_run > 0 else 0.0
            candidates.append({"stage": st.get("stage"), "diff": st.get("diff"),
                               "stage_val_per_run": r2(stage_val), "stage_eff_per_ap": r2(stage_eff),
                               "drops": st.get("drops", [])})
        break
    if not candidates: return None
    if prefer_diff:
        pref = [c for c in candidates if str(c.get("diff") or "") == str(prefer_diff)]
        if pref: return max(pref, key=lambda x: float(x["stage_eff_per_ap"]))
    return max(candidates, key=lambda x: float(x["stage_eff_per_ap"]))

def _open_roulette_boxes_and_apply(event_name: str, num_boxes: int, items_def: dict, materials_index: Dict[str, dict], cum_gained: Dict[str, float], respect_use_flag: bool=True):
    if num_boxes <= 0: return
    blk = get_items_block(event_name, items_def, case="roulette")
    if not blk: return
    token_name = None
    token_rate = 0.0
    for d in blk.get("drops", []):
        item = str(d.get("item") or "")
        rate = float(d.get("rate") or 0.0)
        if not item: continue
        if item in APPLE_ITEM_NAMES: continue
        if item == "교환티켓":
            token_name = item; token_rate = rate; continue
        apply_gain_and_track(item, rate * num_boxes, materials_index, cum_gained, respect_use_flag)
    if token_name and token_rate > 0:
        total_tokens = token_rate * num_boxes
        for ex in blk.get("exchanges", []):
            if str(ex.get("token")) != token_name: continue
            per_token = float(ex.get("per_token") or 1.0)
            options = [str(x) for x in ex.get("options", []) if x]
            alloc = allocate_exchange_tokens_ap_first(total_tokens, per_token, options, materials_index, respect_use_flag)
            for it, qty in alloc:
                apply_gain_and_track(it, qty, materials_index, cum_gained, respect_use_flag)

def _apply_stage_drops(stage_def: dict, materials_index: Dict[str, dict], cum_gained: Dict[str, float], respect_use_flag: bool=True):
    for d in stage_def.get("drops", []):
        item = str(d.get("item") or ""); rate = float(d.get("rate") or 0.0)
        if not item: continue
        apply_gain_and_track(item, rate, materials_index, cum_gained, respect_use_flag)

def _apply_box_event_contents_per_run(event_name: str, stage_def: dict, event_block: dict, quests_def: dict, items_def: dict, materials_index: Dict[str, dict], cum_gained: Dict[str, float], respect_use_flag: bool=True) -> bool:
    contents = _fetch_box_contents(stage_def, event_block, quests_def)
    if not contents:
        contents = _build_box_contents_from_items_json(event_name, items_def)
        if not contents: return False
    box = stage_def.get("box") or {}
    base_gold   = float((box.get("gold")   or {}).get("base", 0.0))
    base_silver = float((box.get("silver") or {}).get("base", 0.0))
    base_bronze = float((box.get("bronze") or {}).get("base", 0.0))
    def _apply_list(lst, base):
        if not lst or base <= 0: return
        has_qty = any('qty_per_box' in (x or {}) for x in lst)
        has_rate = any('rate' in (x or {}) for x in lst)
        n = len(lst)
        for x in lst:
            item = str((x or {}).get("item") or "")
            if not item: continue
            if has_qty: per_box = float((x or {}).get("qty_per_box") or 0.0)
            elif has_rate: per_box = float((x or {}).get("rate") or 0.0)
            else: per_box = 1.0 / n if n > 0 else 0.0
            apply_gain_and_track(item, per_box * base, materials_index, cum_gained, respect_use_flag)
    _apply_list(contents.get("gold", []), base_gold)
    _apply_list(contents.get("silver", []), base_silver)
    _apply_list(contents.get("bronze", []), base_bronze)
    return True

def _list_targets(quests_def: dict, event_filter: Optional[str]) -> List[Tuple[str, str]]:
    seen = set(); out = []
    for e in quests_def.get("event_quests", []):
        ev = str(e.get("event") or ""); cs = str(e.get("case") or "").lower()
        if not ev or cs not in ("roulette", "box", "raid"): continue
        if event_filter and (event_filter not in ev): continue
        key = (ev, cs)
        if key not in seen:
            seen.add(key); out.append(key)
    return out

def _compute_all_bests(targets, quests_def, items_def, materials_index, ap_cost_per_run, prefer_diff, respect_use_flag: bool=True):
    results = []
    for ev, cs in targets:
        if cs == "roulette":
            ce_bonus = _get_ce_bonus(ev)
            best = choose_best_stage_by_total_eff_roulette(ev, quests_def, items_def, ce_bonus, 600.0, ap_cost_per_run, materials_index, respect_use_flag)
            if best:
                best.update({"event": ev, "case": cs, "ce_bonus": ce_bonus})
                results.append(best)
        elif cs == "box":
            best = compute_box_event_best_stage(ev, quests_def, items_def, materials_index, ap_cost_per_run, prefer_diff, respect_use_flag)
            if best:
                best.update({"event": ev, "case": cs})
                results.append(best)
        else:
            best = compute_raid_best_stage(ev, quests_def, materials_index, ap_cost_per_run, respect_use_flag, prefer_diff)
            if best:
                results.append({"event": ev, "case": cs, "stage": best["stage"], "diff": best["diff"],
                                "stage_val_per_run": best["stage_val_per_run"], "stage_eff_per_ap": best["stage_eff_per_ap"],
                                "roulette_eff": 0.0, "total_eff": best["stage_eff_per_ap"]})
    return results

def _pick_global_best(best_list: List[dict]) -> Optional[dict]:
    if not best_list: return None
    def key_fn(x):
        v = x.get("total_eff")
        if v == float("inf"): return float("inf")
        try: return float(v)
        except Exception: return -1e18
    return max(best_list, key=key_fn)

def _get_ce_bonus(event_name: str) -> int:
    st = CE_STATE.get(event_name)
    return int(st["bonus"]) if st else CE_BASE_BONUS

def _get_ce_drop_rate(stage_def: dict, event_block: Optional[dict]) -> float:
    v = stage_def.get("ce_drop_rate")
    if v is None and event_block is not None:
        v = event_block.get("ce_drop_rate")
    try: return float(v or 0.0)
    except Exception: return 0.0

def _update_ce_after_run(event_name: str, stage_def: dict, event_block: Optional[dict]) -> dict:
    if event_name not in CE_STATE:
        return {"p":0.0,"new_drops":0.0,"new_copies_int":0,"gain_int":0,"bonus_inc":0,"new_bonus":_get_ce_bonus(event_name),"rem_to_next":0.0}
    p = _get_ce_drop_rate(stage_def, event_block)
    prev = CE_STATE[event_name]["drops_acc"]; new = prev + p
    prev_floor = int(prev // 1); new_floor = int(new // 1)
    gain_int = max(0, new_floor - prev_floor)
    prev_steps = int(prev // CE_COPIES_PER_PLUS); new_steps = int(new // CE_COPIES_PER_PLUS)
    bonus_inc = max(0, new_steps - prev_steps)
    new_bonus = min(CE_MAX_BONUS, CE_BASE_BONUS + new_steps)
    CE_STATE[event_name]["drops_acc"] = new; CE_STATE[event_name]["bonus"] = new_bonus
    next_step_target = (new_steps + 1) * CE_COPIES_PER_PLUS
    rem_to_next = max(0.0, next_step_target - new)
    return {"p":p,"new_drops":new,"new_copies_int":int(new // 1),"gain_int":gain_int,"bonus_inc":bonus_inc,"new_bonus":new_bonus,"rem_to_next":rem_to_next}

def _init_ce_state_for_targets(targets):
    for ev, cs in targets:
        if cs == "roulette" and ev not in CE_STATE:
            CE_STATE[ev] = {"drops_acc": 0.0, "bonus": CE_BASE_BONUS}

def _print_final_materials_summary(write_line, initial_lack: Dict[str, float], materials_index: Dict[str, dict], cum_gained: Dict[str, float], respect_use_flag: bool=True) -> None:
    final_lack = snapshot_lack(materials_index, respect_use_flag)
    names = set(initial_lack.keys()) | set(cum_gained.keys()) | set(final_lack.keys())
    rows = []
    for name in names:
        rec = materials_index.get(name)
        if respect_use_flag and rec is not None and not rec.get("use", True):
            continue
        target = float(initial_lack.get(name, 0.0))
        got = float(cum_gained.get(name, 0.0))
        remain = float(final_lack.get(name, max(0.0, target - got)))
        if target == 0.0 and got == 0.0 and remain == 0.0:
            continue
        rows.append([name, target, got, remain])
    rows.sort(key=lambda r: _material_sort_key(r[0]))
    if not rows:
        write_line("(최종 재료 현황: 출력할 항목 없음)"); return
    headers = ["재료", "목표", "획득", "부족"]
    fmt_rows = [[r[0], f0(r[1]), f0(r[2]), f0(r[3])] for r in rows]
    _print_table(write_line, headers, fmt_rows, aligns=["left", "right", "right", "right"])

def _prepend_lines_to_file(filepath: str, lines: List[str]) -> None:
    try:
        with open(filepath, "r", encoding="utf-8") as f: original = f.read()
        with open(filepath, "w", encoding="utf-8") as f:
            for ln in lines: f.write(ln + "\n")
            f.write("\n"); f.write(original)
    except Exception: pass

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--materials", default="materials.json")
    parser.add_argument("--quests", default="event_quests.json")
    parser.add_argument("--items",  default="event_items.json")
    parser.add_argument("--event",  default=None)
    parser.add_argument("--diff",   default=None)
    parser.add_argument("--ap-cost", type=float, default=40.0)
    parser.add_argument("--ignore-use-flag", action="store_true")
    parser.add_argument("--log", default="run_log.txt")
    parser.add_argument("--table-format", choices=["text", "md", "csv"], default="text")
    parser.add_argument("--table-style", choices=["box","ascii"], default="ascii")
    parser.add_argument("--ambiguous-wide", action="store_true")
    parser.add_argument("--ascii-arrow", action="store_true")
    parser.add_argument("--ascii-bullet", action="store_true")
    args = parser.parse_args()

    global TABLE_FORMAT, TABLE_STYLE, AMBIGUOUS_WIDE, ARROW, BULLET
    TABLE_FORMAT = args.table_format
    TABLE_STYLE  = args.table_style
    AMBIGUOUS_WIDE = bool(args.ambiguous_wide)
    if args.ascii_arrow: ARROW = "->"
    if args.ascii_bullet: BULLET = "-"

    logger = Logger(args.log, tee=False); w = logger.write

    materials_json = load_json(args.materials)
    init_rarity_map_from_materials(materials_json)
    materials_index = to_material_index(materials_json)
    init_sort_index_from_materials(materials_json)

    quests_def = load_json(args.quests)
    try: items_def = load_json(args.items)
    except Exception: items_def = {}

    unknown_map = validate_item_names(materials_index, quests_def, items_def)
    if unknown_map:
        w("## 경고: materials.json에 없는 아이템명이 참조되었습니다")
        known_names_sorted = sorted(materials_index.keys())
        for nm in sorted(unknown_map.keys(), key=lambda x: x):
            locs = ", ".join(unknown_map[nm])
            suggestions = difflib.get_close_matches(nm, known_names_sorted, n=3, cutoff=0.6)
            sug = (" | 유사: " + ", ".join(suggestions)) if suggestions else ""
            w(f"- {nm}  | 위치 예시: {locs}{sug}")
        w("")

    respect_use_flag = not args.ignore_use_flag
    initial_lack = snapshot_lack(materials_index, respect_use_flag)
    targets = _list_targets(quests_def, args.event)
    _init_ce_state_for_targets(targets)

    total_ap = (
        APPLE_COUNTS.get("gold", 0)   * APPLE_AP_BY_POOL["gold"]   +
        APPLE_COUNTS.get("silver", 0) * APPLE_AP_BY_POOL["silver"] +
        APPLE_COUNTS.get("blue", 0)   * APPLE_AP_BY_POOL["blue"]   +
        APPLE_COUNTS.get("copper", 0) * APPLE_AP_BY_POOL["copper"] +
        float(NATURAL_AP or 0.0)
    )
    w(f"AP 풀: {f2(total_ap)}  | AP/판={f2(args.ap_cost)}  | 표 포맷={args.table_format}, 스타일={args.table_style}")
    w(f"# 룰렛 보너스: 시작 {CE_BASE_BONUS}, {CE_COPIES_PER_PLUS}장당 +1, 최대 {CE_MAX_BONUS}")

    if not targets:
        w("대상 이벤트 없음.")
        logger.close()
        print(f"[로그 저장 완료] {logger.filepath}")
        return

    ap_pool = total_ap
    tickets_acc_by_event: Dict[str, float] = {}
    need_tickets_cache: Dict[str, float] = {}
    roulette_refund_per_box: Dict[str, float] = {}
    cum_gained: Dict[str, float] = {}

    last_choice_key = None
    run_idx = 0
    session_segments: List[Tuple[str, str, int]] = []
    prev_session_key: Optional[Tuple[str, str]] = None

    while ap_pool >= args.ap_cost:
        run_idx += 1
        global CURRENT_RUN_GAINS; CURRENT_RUN_GAINS = {}

        bests_before = _compute_all_bests(targets, quests_def, items_def, materials_index, args.ap_cost, args.diff, respect_use_flag)
        global_best = _pick_global_best(bests_before)
        if not global_best:
            w("※ 선택할 스테이지 없음 → 중단"); break

        ev = global_best["event"]; cs = global_best["case"]
        stage_name = global_best["stage"]; diff = global_best["diff"]
        ce_bonus_for_line = global_best.get("ce_bonus", _get_ce_bonus(ev))

        choice_key = f"{ev}|{cs}|{stage_name}|{diff}"
        stage_changed_trigger = (last_choice_key is None or choice_key != last_choice_key)
        sess_key = (ev, diff)
        if prev_session_key != sess_key:
            session_segments.append((ev, diff, 1)); prev_session_key = sess_key
        else:
            name, d, cnt = session_segments[-1]
            session_segments[-1] = (name, d, cnt + 1)

        ap_pool -= args.ap_cost
        block = _get_event_block(quests_def, ev, cs); stage_def = None
        if block:
            for st in block.get("stages", []):
                if str(st.get("stage") or "") == stage_name and str(st.get("diff") or "") == str(diff):
                    stage_def = st; break
        if not stage_def:
            last_choice_key = choice_key; continue

        lack_before = snapshot_lack(materials_index, respect_use_flag)
        _apply_stage_drops(stage_def, materials_index, cum_gained, respect_use_flag)

        opened = 0; refund_gain = 0.0; last_tpr_for_run = 0.0
        if cs == "roulette":
            ce_bonus = _get_ce_bonus(ev)
            last_tpr_for_run = tickets_per_run(stage_def, ce_bonus)
            tickets_acc_by_event[ev] = tickets_acc_by_event.get(ev, 0.0) + last_tpr_for_run
            if ev not in need_tickets_cache:
                need_tickets_cache[ev] = extract_need_tickets_from_items(ev, items_def, default=600.0)
            if ev not in roulette_refund_per_box:
                _, ap_refund, _ = compute_per_box_value_and_refund(ev, items_def, materials_index, respect_use_flag=False)
                roulette_refund_per_box[ev] = float(ap_refund or 0.0)
            need_tk = need_tickets_cache[ev]
            if need_tk > 0 and tickets_acc_by_event[ev] >= need_tk:
                opened = int(tickets_acc_by_event[ev] // need_tk)
                tickets_acc_by_event[ev] -= opened * need_tk
                _open_roulette_boxes_and_apply(ev, opened, items_def, materials_index, cum_gained, respect_use_flag)
                refund_gain = opened * roulette_refund_per_box.get(ev, 0.0)
                if refund_gain > 0: ap_pool += refund_gain
        elif cs == "box":
            if block:
                _apply_box_event_contents_per_run(ev, stage_def, block, quests_def, items_def, materials_index, cum_gained, respect_use_flag)

        _apply_special_per_run_yields(ev, materials_index, cum_gained, respect_use_flag)

        lack_after = snapshot_lack(materials_index, respect_use_flag)
        lack_zero_items = []
        for name, b in lack_before.items():
            a = lack_after.get(name, 0.0)
            if b > 0 and a == 0: lack_zero_items.append((name, b, cum_gained.get(name, 0.0)))

        ce_trigger_info = None
        if cs == "roulette":
            ce_info = _update_ce_after_run(ev, stage_def, block)
            if ce_info["new_bonus"] < CE_MAX_BONUS and (ce_info["gain_int"] > 0 or ce_info["bonus_inc"] > 0):
                ce_trigger_info = ce_info

        should_log = stage_changed_trigger or (len(lack_zero_items) > 0) or (ce_trigger_info is not None)
        ce_only_trigger = (ce_trigger_info is not None) and (not stage_changed_trigger) and (len(lack_zero_items) == 0)

        if should_log:
            if stage_changed_trigger:
                if cs == "roulette":
                    w(f"[Run {run_idx}] 스테이지 변경 → {ev} [{cs}] {stage_name} ({diff})  | 보너스={ce_bonus_for_line}  | total_eff={f2s(global_best['total_eff'])}")
                else:
                    w(f"[Run {run_idx}] 스테이지 변경 → {ev} [{cs}] {stage_name} ({diff})  | total_eff={f2s(global_best['total_eff'])}")
            else:
                if cs == "roulette":
                    ce_state = CE_STATE.get(ev, {"drops_acc": 0.0, "bonus": CE_BASE_BONUS})
                    current_int = int(ce_state["drops_acc"] // 1)
                    w(f"[Run {run_idx}] 상태 기록 → {ev} [{cs}] {stage_name} ({diff})  | 현재 보너스={ce_state['bonus']} | 예장={current_int}장")
                else:
                    w(f"[Run {run_idx}] 상태 기록 → {ev} [{cs}] {stage_name} ({diff})")
            if ce_only_trigger:
                w(""); w("")
                last_choice_key = choice_key
                continue

            for name, b, total in lack_zero_items:
                w(f"  - [Run {run_idx}] 재료 충족: {name}  (부족 {f2(b)} -> 0)  | 누적 획득 {f2(total)}")

            if ce_trigger_info is not None and not ce_only_trigger:
                gi = ce_trigger_info["gain_int"]; bi = ce_trigger_info["bonus_inc"]; cur_int = ce_trigger_info["new_copies_int"]
                if gi > 0: w(f"  - 예장 드랍: +{gi}장 (현재 {cur_int}장, 누적 기대 {f2(ce_trigger_info['new_drops'])}장)")
                if bi > 0: w(f"    -> 보너스 +{bi} ⇒ 현재 {ce_trigger_info['new_bonus']}  (다음 +1까지 {f2(ce_trigger_info['rem_to_next'])}장 기대)")

            w("변동된 결과 (이 판):")
            _print_gain_table(w, CURRENT_RUN_GAINS, lack_before, lack_after, cum_gained)

            if cs == "roulette":
                need_tk = need_tickets_cache.get(ev, 0.0)
                ce_state = CE_STATE.get(ev, {"drops_acc": 0.0, "bonus": CE_BASE_BONUS})
                cur_int = int(ce_state["drops_acc"] // 1)
                suffix = ""
                if ce_state["bonus"] < CE_MAX_BONUS:
                    rem = max(0.0, CE_COPIES_PER_PLUS - (ce_state["drops_acc"] % CE_COPIES_PER_PLUS))
                    suffix = f", 다음 +1까지 {f2(rem)}장"
                w(f"룰렛: 티켓 {f2(tickets_acc_by_event.get(ev, 0.0))}/{f2(need_tk)} (+{f2(last_tpr_for_run)}/판) | 환급AP +{f2(refund_gain)} | AP 풀 {f2(ap_pool)} | 예장 {cur_int}장(보너스 {ce_state['bonus']}{suffix})")

            bests_after = _compute_all_bests(targets, quests_def, items_def, materials_index, args.ap_cost, args.diff, respect_use_flag)
            w("\n현재 이벤트 효율 요약:")
            _print_eff_table(w, bests_after, args.ap_cost)
            w(""); w("")

        last_choice_key = choice_key

    w(f"# 종료: 총 실행 {run_idx}판, 잔여 AP 풀={f2(ap_pool)}")
    w("")
    w("## 최종 재료 현황 (목표/획득/부족)")
    _print_final_materials_summary(w, initial_lack, materials_index, cum_gained, respect_use_flag)
    logger.close()

    header = ["## 주회 세션(순서대로) — 이벤트별 연속 주행 구간 요약"]
    body = [f"  {i+1:>2}. {name} [{d}] — {cnt}판" for i, (name, d, cnt) in enumerate(session_segments)]
    lines = header + body + ["", "## 원본 로그 ↓", ""]
    for ln in header + body: print(ln)
    print()
    _prepend_lines_to_file(args.log, lines)
    print(f"[로그 저장 완료] {logger.filepath}")

if __name__ == "__main__":
    main()
</script>

<!-- 2) 기본 JSON 세트(사용자 입력으로 have/need만 바꿔서 다시 저장해서 사용) -->
<script id="materials-json" type="application/json">{"materials":[{"item":"금사과","tier":"사과","ap_per_item":0,"have":0,"need":0,"lack":0,"use":"Y"},{"item":"은사과","tier":"사과","ap_per_item":0,"have":0,"need":0,"lack":0,"use":"Y"},{"item":"청사과","tier":"사과","ap_per_item":0,"have":0,"need":0,"lack":0,"use":"Y"},{"item":"동사과","tier":"사과","ap_per_item":0,"have":0,"need":0,"lack":0,"use":"Y"},{"item":"묘목","tier":"사과","ap_per_item":0,"have":177,"need":0,"lack":0,"use":"Y"},{"item":"퓨어프리즘","tier":"퓨어프리즘","ap_per_item":0,"have":2073,"need":0,"lack":0,"use":"Y"},<?php?></script>
<script id="event-quests-json" type="application/json">{{EVENT_QUESTS}}</script>
<script id="event-items-json" type="application/json">{{EVENT_ITEMS}}</script>

<!-- 위 materials-json의 앞부분 두 항목(사과/묘목/프리즘)은 UI에서 제외할 예정이므로 실제 값은 의미없습니다.
     아래 JS가 base JSON을 교체/보정합니다. -->

<script>
/* ======== (빌드 타임 치환) 업로드하신 JSON을 주입 ======== */
document.getElementById('event-quests-json').textContent = <?=
JSON.stringify(<?=`<?=`?>`.trim(),null,2)?> // dummy to keep html block intact
</script>
<!-- ↑ 위 PHP 표시는 “그냥 무시”하세요. GitHub Pages/Netlify에선 그대로 텍스트로 남습니다.
     실제 본문은 아래 JS에서 넣습니다.  -->

<script>
/* ─────────────────────────────────────────────────────────
   0) 데이터 삽입: (여기에 실제 JSON 본문을 넣습니다)
   ───────────────────────────────────────────────────────── */
const RAW_MATERIALS = JSON.parse(`<?=`?>`);
const RAW_EVENT_QUESTS = JSON.parse(String.raw`{{EVENT_QUESTS_PAYLOAD}}`);
const RAW_EVENT_ITEMS  = JSON.parse(String.raw`{{EVENT_ITEMS_PAYLOAD}}`);

/* ─────────────────────────────────────────────────────────
   1) Pyodide 준비
   ───────────────────────────────────────────────────────── */
let pyodidePromise = null;
async function ensurePyodide() {
  if (pyodidePromise) return pyodidePromise;
  pyodidePromise = new Promise(async (resolve, reject) => {
    try {
      setStatus("Pyodide 로딩 중... (최초 5–20초)");
      const { loadPyodide } = await import('https://cdn.jsdelivr.net/pyodide/v0.26.2/full/pyodide.js');
      const pyodide = await loadPyodide({indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.26.2/full/'});
      setStatus("Python 준비됨");
      resolve(pyodide);
    } catch (e) {
      setStatus("Pyodide 로딩 실패", true);
      reject(e);
    }
  });
  return pyodidePromise;
}

/* ─────────────────────────────────────────────────────────
   2) UI — 재료 테이블 렌더
   ───────────────────────────────────────────────────────── */
const EXCLUDE_NAME_RULE = (name) => {
  if (!name) return true;
  const n = String(name);
  return (
    n.includes("금사과") || n.includes("은사과") || n.includes("청사과") || n.includes("동사과") ||
    n.includes("묘목") || n.includes("퓨어프리즘") ||
    n.includes("인연") || n.includes("Bond") ||
    n.includes("종화")
  );
};
const matTableBody = document.getElementById('matBody');
const qInput = document.getElementById('q');

function cloneBaseMaterials() {
  return JSON.parse(JSON.stringify(RAW_MATERIALS));
}

function toViewRows(base) {
  return base.materials.filter(m => !EXCLUDE_NAME_RULE(m.item));
}

function renderTable() {
  const kw = qInput.value.trim();
  const base = cloneBaseMaterials();
  const rows = toViewRows(base).filter(m => !kw || String(m.item).includes(kw));
  matTableBody.innerHTML = "";
  for (const m of rows) {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${m.item === "QP" ? "QP (단위: <b>백만</b>)" : m.item}</td>
      <td>${m.tier ?? ""}</td>
      <td class="right">${m.ap_per_item ?? 0}</td>
      <td>${(m.use ?? "Y")}</td>
      <td><input type="number" step="${m.item==="QP" ? "0.1" : "1"}" min="0" value="${m.item==="QP" ? (Number(m.have||0)/1_000_000) : (m.have||0)}" data-item="${m.item}" data-kind="have" class="${m.item==="QP" ? "qp" : ""}"></td>
      <td><input type="number" step="${m.item==="QP" ? "0.1" : "1"}" min="0" value="${m.item==="QP" ? (Number(m.need||0)/1_000_000) : (m.need||0)}" data-item="${m.item}" data-kind="need" class="${m.item==="QP" ? "qp" : ""}"></td>
    `;
    matTableBody.appendChild(tr);
  }
}

qInput.addEventListener('input', renderTable);

/* ─────────────────────────────────────────────────────────
   3) 실행 — JSON 파일로 기록 → 파이썬 실행 → 로그 읽기
   ───────────────────────────────────────────────────────── */
function setStatus(msg, isErr=false){ 
  const el = document.getElementById('status');
  el.textContent = "— " + msg;
  el.className = isErr ? "err" : "muted";
}
function setLog(text){ document.getElementById('log').textContent = text; }

async function runSimulation(){
  const btn = document.getElementById('btnRun');
  btn.disabled = true;
  try{
    const pyodide = await ensurePyodide();

    // 3-1) 사용자 입력 반영 — materials.json 재구성
    const base = cloneBaseMaterials();
    const viewMap = {};
    document.querySelectorAll('#matBody input').forEach(inp=>{
      const item = inp.dataset.item, kind = inp.dataset.kind;
      const v = Number(inp.value || 0);
      if(!viewMap[item]) viewMap[item]={have:0,need:0};
      viewMap[item][kind] = v;
    });

    for (const m of base.materials) {
      // UI에 없는 항목(사과/묘목/프리즘/인연/종화)은 사용하지 않도록 고정
      if (EXCLUDE_NAME_RULE(m.item)) {
        m.use = "N";
        m.lack = 0;
        continue;
      }
      const rec = viewMap[m.item] || {have:Number(m.have||0), need:Number(m.need||0)};
      let have = rec.have, need = rec.need;
      if (m.item === "QP"){ // QP는 100만 단위
        have = Math.round((Number(have)||0) * 1_000_000);
        need = Math.round((Number(need)||0) * 1_000_000);
      }
      m.have = have;
      m.need = need;
      m.lack = Math.max(0, Number(need)-Number(have));
      m.use = (m.use ?? "Y");
    }

    // 3-2) event json 그대로 사용
    const eventQuests = RAW_EVENT_QUESTS;
    const eventItems  = RAW_EVENT_ITEMS;

    // 3-3) Py 파일/JSON 파일 기록
    const pyCode = document.getElementById('py-sim').textContent;
    pyodide.FS.writeFile("simulator.py", pyCode, {encoding:"utf-8"});
    pyodide.FS.writeFile("materials.json", JSON.stringify(base), {encoding:"utf-8"});
    pyodide.FS.writeFile("event_quests.json", JSON.stringify(eventQuests), {encoding:"utf-8"});
    pyodide.FS.writeFile("event_items.json",  JSON.stringify(eventItems),  {encoding:"utf-8"});

    // 사과 수량
    const ap = {
      gold:   Number(document.getElementById('apGold').value||0),
      silver: Number(document.getElementById('apSilver').value||0),
      blue:   Number(document.getElementById('apBlue').value||0),
      copper: Number(document.getElementById('apCopper').value||0),
    };

    setStatus("시뮬레이터 실행 중…");
    const log = await pyodide.runPythonAsync(`
import sys, json, simulator
simulator.APPLE_COUNTS = ${JSON.stringify(ap)}
simulator.NATURAL_AP = 0.0
sys.argv = ["simulator.py",
            "--materials","materials.json",
            "--quests","event_quests.json",
            "--items","event_items.json",
            "--ap-cost","40",
            "--table-format","text",
            "--table-style","ascii",
            "--log","run_log.txt"]
simulator.main()
open("run_log.txt","r",encoding="utf-8").read()
    `);
    setStatus("완료!");
    setLog(log);
  }catch(e){
    setStatus("실행 오류", true);
    setLog(String(e && e.message ? e.message : e));
  }finally{
    btn.disabled = false;
  }
}

/* ─────────────────────────────────────────────────────────
   4) 시작
   ───────────────────────────────────────────────────────── */
document.getElementById('btnRun').addEventListener('click', runSimulation);
renderTable();
setStatus("준비됨");
</script>

</body>
</html>
